# yamllint disable rule:document-start
# yamllint disable rule:truthy
# yamllint disable rule:line-length
# Automatically checks for new Sight LSP releases and creates PRs to update the extension
name: Update Sight Version

on:
  schedule:
    # Run daily at midnight UTC
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      version:
        description: 'Sight version to update to (e.g., v0.1.17). Leave empty to use latest release.'
        required: false
        type: string

permissions:
  contents: write      # Needed to push branches
  pull-requests: write # Needed to create PRs

jobs:
  # First job: Check if an update is needed
  check-for-update:
    runs-on: ubuntu-latest
    outputs:
      needs_update: ${{ steps.check.outputs.needs_update }}
      latest_version: ${{ steps.check.outputs.latest_version }}
      current_version: ${{ steps.check.outputs.current_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check for updates
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Extract current SERVER_VERSION from src/lib.rs
          CURRENT_VERSION=$(grep -oP 'const SERVER_VERSION: &str = "\K[^"]+' src/lib.rs) || true
          if [ -z "$CURRENT_VERSION" ]; then
            echo "::error::Failed to extract SERVER_VERSION from src/lib.rs"
            exit 1
          fi
          echo "current_version=$CURRENT_VERSION" >> "$GITHUB_OUTPUT"
          echo "Current SERVER_VERSION: $CURRENT_VERSION"

          # Determine target version (manual input or latest release)
          if [ -n "${{ inputs.version }}" ]; then
            LATEST_VERSION="${{ inputs.version }}"
            echo "Using manually specified version: $LATEST_VERSION"
          else
            # Fetch latest release tag from jbearak/sight repo.
            # IMPORTANT: on 404/permission failures, GitHub APIs may return a JSON error body.
            # Avoid capturing that JSON into LATEST_VERSION by only reading stdout on success.
            # NOTE: If the repo is private, github.token won't have access and GitHub returns 404.
            tmp_out=$(mktemp)
            tmp_err=$(mktemp)

            # Try GitHub Releases first.
            # If the repo has no Releases, this endpoint returns 404 even when the repo is public.
            if gh api repos/jbearak/sight/releases/latest --jq '.tag_name' >"$tmp_out" 2>"$tmp_err"; then
              LATEST_VERSION=$(cat "$tmp_out")
            else
              err_line=$(tail -n 1 "$tmp_err" | tr -d '\n' | tr -d '\r')

              if printf '%s' "$err_line" | grep -q 'HTTP 404'; then
                # `/releases/latest` returns 404 when there are no *stable* releases.
                # (Common case: only prereleases exist.)
                # Fallback order:
                #  1) most recent release (including prereleases)
                #  2) most recent tag

                if gh api 'repos/jbearak/sight/releases?per_page=1' --jq '.[0].tag_name' >"$tmp_out" 2>"$tmp_err"; then
                  LATEST_VERSION=$(cat "$tmp_out")
                elif gh api 'repos/jbearak/sight/tags?per_page=1' --jq '.[0].name' >"$tmp_out" 2>"$tmp_err"; then
                  LATEST_VERSION=$(cat "$tmp_out")
                else
                  echo "::error::Failed to fetch latest release or tag from jbearak/sight."
                  echo "::error::gh stderr: $(tail -n 1 "$tmp_err" | tr -d '\n' | tr -d '\r')"
                  rm -f "$tmp_out" "$tmp_err"
                  exit 1
                fi
              else
                echo "::error::Failed to fetch latest release tag from jbearak/sight."
                echo "::error::gh stderr: $err_line"
                rm -f "$tmp_out" "$tmp_err"
                exit 1
              fi
            fi

            rm -f "$tmp_out" "$tmp_err"

            if [ -z "$LATEST_VERSION" ] || [ "$LATEST_VERSION" = "null" ]; then
              echo "::error::Latest version was empty/null (no releases and no tags?)"
              exit 1
            fi

            # Basic sanity check: release tags should not look like JSON
            if printf '%s' "$LATEST_VERSION" | grep -q '^[[:space:]]*{'; then
              echo "::error::Expected a tag name string but got JSON; refusing to continue"
              exit 1
            fi

            echo "Latest sight release: $LATEST_VERSION"
          fi

          # Write output safely (no newlines)
          LATEST_VERSION_ONELINE=$(printf '%s' "$LATEST_VERSION" | tr -d '\n' | tr -d '\r')
          echo "latest_version=$LATEST_VERSION_ONELINE" >> "$GITHUB_OUTPUT"

          # Skip if already up to date
          if [ "$CURRENT_VERSION" = "$LATEST_VERSION" ]; then
            echo "Already up to date"
            echo "needs_update=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Skip if PR already exists for this version
          EXISTING_PR=$(gh pr list --search "Update sight to $LATEST_VERSION" --state open --json number --jq '.[0].number')
          if [ -n "$EXISTING_PR" ]; then
            echo "PR #$EXISTING_PR already exists for version $LATEST_VERSION"
            echo "needs_update=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Update needed: $CURRENT_VERSION -> $LATEST_VERSION"
          echo "needs_update=true" >> "$GITHUB_OUTPUT"

  # Second job: Update files, rebuild WASM, and create PR
  update-and-build:
    needs: check-for-update
    if: needs.check-for-update.outputs.needs_update == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Install Rust with WASM target before running update_version.sh
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-wasip1

      - name: Update version files
        id: update
        run: |
          LATEST_VERSION="${{ needs.check-for-update.outputs.latest_version }}"

          # Defensive check: if the previous job accidentally produced JSON/error text, fail early
          if printf '%s' "$LATEST_VERSION" | grep -q '^[[:space:]]*{'; then
            echo "::error::Invalid latest_version output (looks like JSON). Check repo access / GitHub token permissions."
            echo "::error::latest_version was: $LATEST_VERSION"
            exit 1
          fi

          # Configure git identity for commits (needed by update_version.sh)
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Capture current extension version for PR description (first version line only, not [lib] version)
          CURRENT_EXT_VERSION=$(grep -oP '^version = "\K[^"]+' extension.toml | head -1) || true
          if [ -z "$CURRENT_EXT_VERSION" ]; then
             echo "::error::Failed to extract version from extension.toml"
             exit 1
          fi
          echo "current_ext_version=$CURRENT_EXT_VERSION" >> "$GITHUB_OUTPUT"

          # Run update script (updates src/lib.rs, Cargo.toml, extension.toml, rebuilds WASM, commits)
          chmod +x update_version.sh
          ./update_version.sh --sight-version "$LATEST_VERSION"

          # Capture new extension version for PR description (first version line only)
          NEW_EXT_VERSION=$(grep -oP '^version = "\K[^"]+' extension.toml | head -1)
          echo "new_ext_version=$NEW_EXT_VERSION" >> "$GITHUB_OUTPUT"

      - name: Verify WASM file
        run: |
          # Sanity check: ensure WASM file was rebuilt and is reasonable size
          WASM_SIZE=$(stat -c%s extension.wasm)
          echo "WASM file size: $WASM_SIZE bytes"

          if [ "$WASM_SIZE" -lt 100000 ]; then
            echo "Error: WASM file is too small (< 100KB), build may have failed"
            exit 1
          fi

          echo "WASM file size is reasonable"

      - name: Create Pull Request
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          LATEST_VERSION="${{ needs.check-for-update.outputs.latest_version }}"
          CURRENT_VERSION="${{ needs.check-for-update.outputs.current_version }}"
          CURRENT_EXT_VERSION="${{ steps.update.outputs.current_ext_version }}"
          NEW_EXT_VERSION="${{ steps.update.outputs.new_ext_version }}"
          BRANCH_NAME="update-sight-$(echo "$LATEST_VERSION" | tr '/' '-')"

          # Create branch (update_version.sh already committed the changes)
          git checkout -b "$BRANCH_NAME"

          # Push branch to origin
          git push origin "$BRANCH_NAME"

          # Create PR
          printf '%s\n' \
            "## Summary" \
            "" \
            "This PR updates the sight language server to **${LATEST_VERSION}**." \
            "" \
            "### Changes" \
            "- SERVER_VERSION: ${CURRENT_VERSION} -> ${LATEST_VERSION}" \
            "- Extension version: ${CURRENT_EXT_VERSION} -> ${NEW_EXT_VERSION}" \
            "- Rebuilt extension.wasm" \
            "" \
            "### Testing Checklist" \
            "- [ ] Install extension in Zed" \
            "- [ ] Open a .do file and verify LSP starts" \
            "- [ ] Check hover/go-to-definition" \
            "" \
            "---" \
            "*Automated PR from update-sight-version workflow.*" > /tmp/pr-body.md

          gh pr create \
            --title "Update sight to $LATEST_VERSION" \
            --label "automated" \
            --body-file /tmp/pr-body.md
